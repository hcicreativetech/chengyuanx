## DESIGNING FOR TINKERABILITY 
First time exposed to the idea of tinkering/tinkerability, it is almost like every learning experience of mine outside school education. Without clear instructions or guidance, it is human nature to try things and infer the rules, with or without a clear goal. Often there is a fuzzy intent like "I want to learn to code" but an immediate next step is either unclear or pivoted quite often due to discoveries found through tinkering. 

I agree that a design decision in Scratch described as "blocks snap together only if the combination makes sense... there can be no syntax errors" was a key not to discourage tinkering. Through instant feedback, tinkerers observe and learn in the process of trying, with clear indication of which steps that work or do not work. 

Coding IDEs are great examples to encourage tinkering in STEM. Advanced IDEs used the linter tools to flag syntax errors or potential bugs. It is hard to prevent people from making mistakes, but immediate feedback from linter encouraged coders to reflect on the code they just typed. 

Another tinkering encouraging choice in coding is the interpreted language, like Python. Interpreted language runs the code script sequentially, at least from the entry point, making it easy to track what the computer is "thinking" right now. It also makes the debugging easier as the computer would naturally stop at the line that baffled it. Interpreted language allow testing and debugging while creating, which encourages user to code in blocks and proceed with many small milestones. In contrast, coding in compiled language like C rewards people with a successful compilation and execution. But the risk of compiling error, even before one can evaluate the logic or design decisions, discourages many learners at every stage of their coding experience. Albeit clear debugging instructions that came with many compilers, the risk like memory leak could still force the coder to spend time just locating the error.
