## DESIGNING FOR TINKERABILITY 
First time exposed to the idea of tinkering/tinkerability, it is almost like every learning experience of mine outside school education. Without clear instructions or guidance, it is human nature to try things and infer the rules, with or without a clear goal. Often there is a fuzzy intent like "I want to learn to code" but an immediate next step is either unclear or pivoted quite often due to discoveries found through tinkering. 

I agree that a design decision in Scratch described as "blocks snap together only if the combination makes sense... there can be no syntax errors" was a key not to discourage tinkering. Through instant feedback, tinkerers observe and learn in the process of trying, with clear indication of which steps that work or do not work. 

Coding IDEs are great examples to encourage tinkering in STEM. Advanced IDEs used the linter tools to flag syntax errors or potential bugs. It is hard to prevent people from making mistakes, but immediate feedback from linter encouraged coders to reflect on the code they just typed. 

Another tinkering encouraging choice in coding is the interpreted language, like Python. In contrast, with the risk of compiling error (before one can even evaluate the logic or design decisions), compiled language like C discourages many learners at every stage of their coding experience. Albeit clear debugging instructions that came with many compilers, the risk like memory leak could still force the coder to spend time locating the error.
